-- hash to store item and tier as one field
ITEMTIER_HASH = 0xFFFF

-- make defining absurd prices easier
STACK_100CC = 10000 * 100

STORAGE_FORGE_DUST_LEVEL = 909090

-- storage key on which the forge dust balance will be stored
FORGE_DUST_STORAGE = 808080 + RESOURCE_FORGE_DUST

-- item constants
ITEM_FORGE_DUST = 41995 -- not meant to be in-game item
ITEM_FORGE_SLIVERS = 41944
ITEM_FORGE_CORES = 41945
ITEM_FORGE_CHEST = 42396


-- items that will act as forge
ITEM_FORGE_PLACE_FIRST = 41950
ITEM_FORGE_PLACE_LAST = 41977

-- forge actions
FORGE_ACTION_FUSION = 0
FORGE_ACTION_TRANSFER = 1
FORGE_ACTION_DUSTTOSLIVERS = 2
FORGE_ACTION_SLIVERSTOCORES = 3
FORGE_ACTION_INCREASELIMIT = 4

FORGE_ACTION_CONVERSION = 2 -- for history tab

if (not ForgeHistoryCheckTime) then --se nao existe esse (startup nao existe, se for dar reload ja existe)
    ForgeHistoryCheckTime = { --entao cria
        timeToRefresh = 15, --seconds
        players = {}
    }
end

-- forge results
FORGE_RESULT_FAILURE = 0
FORGE_RESULT_SUCCESS = 1

-- forge bonuses
FORGE_BONUS_NONE = 0
FORGE_BONUS_DUSTKEPT = 1 -- dust not consumed
FORGE_BONUS_CORESKEPT = 2 -- cores not consumed
FORGE_BONUS_GOLDKEPT = 3 -- gold not consumed
FORGE_BONUS_ITEMKEPT_ONETIERLOST = 4 -- item not consumed, lost 1 tier only
FORGE_BONUS_ITEMKEPT_NOTIERLOST = 5 -- second item and its tier kept
FORGE_BONUS_BOTHUPGRADED = 6 -- both items gained tier
FORGE_BONUS_EXTRATIER = 7 -- item gained two tiers
FORGE_BONUS_ITEMNOTCONSUMED = 8 -- second item did not lose a tier
    
-- error handler
--[[
    normally the player should not be able to reach these error states
    this handles weird situations such as:
    - player trading while using forge
    - player resources changing when being in forge window
    - player's client sending bad requests to the forge
]]

FORGE_ERROR_NOTENOUGHGOLD = 1
FORGE_ERROR_NOTENOUGHDUST = 2
FORGE_ERROR_NOTENOUGHSLIVERS = 3
FORGE_ERROR_NOTENOUGHCORES = 4
FORGE_ERROR_NOTENOUGHITEMS = 5
FORGE_ERROR_NOTENOUGHCAP = 6
FORGE_ERROR_NOTENOUGHROOM = 7
FORGE_ERROR_NOTUPGRADEABLE = 8
FORGE_ERROR_MAXDUSTLEVELREACHED = 9
FORGE_ERROR_BADLEVELINCREASEPRICE = 10
FORGE_ERROR_TIERTOOHIGH = 11
FORGE_ERROR_NOTINFORGE = 12
FORGE_ERROR_BADREQUEST = 13

-- cache forge data to resend ui after dust level upgrade
FORGE_CACHE_TYPE_BYTE = 1
FORGE_CACHE_TYPE_U16 = 2
ForgeCache = {}

-- this table has three functions:
-- number of classes in game
-- price for each class/tier
-- number of tiers in classes (autogenerated from prices)
-- NOTE: 1kk = 100cc

--
-- BEGIN CONFIG
--
local forgeMeta = {
    [1] = { -- class
        25000 -- price to fuse two [class 1, tier 0] items into one tier 1 item
    },
    [2] = {
        750000, -- 750k
        5 * STACK_100CC -- 5kk
    },
    [3] = {
        4 * STACK_100CC, -- 4kk
        10 * STACK_100CC, -- 10kk
        20 * STACK_100CC -- 20kk
    },
    [4] = {
        8 * STACK_100CC, -- 8kk
        20 * STACK_100CC, -- 20kk
        40 * STACK_100CC, -- 40kk
        65 * STACK_100CC, -- 65kk
        100 * STACK_100CC, -- 100kk
        250 * STACK_100CC, -- 250kk
        750 * STACK_100CC, -- 750kk
        2500 * STACK_100CC, -- 2500kk
        8000 * STACK_100CC, -- 8000kk
        15000 * STACK_100CC -- 15000kk
    }
}

local forgeData = {
    -- server side forge logic
    allowCustomItemFusion = false, -- original: false
    allowCustomItemTransfer = false, -- original: false
    historyEntriesPerPage = 9,
    
    -- bytes sent to the client
    sliversDustCost = 20, -- (conversion) (left column top) cost to make 1 bottom item
    sliversPerConversion = 3, -- (conversion) (left column bottom) how many items to make
    coreSliversCost = 50, -- (conversion) (middle column top) cost to make 1
    dustLimitIncreaseCost = 75, -- (conversion) (right column top) current stored dust limit minus this number = cost to increase stored dust limit
    minStoredDustLimit = 100, -- (conversion) (right column bottom) starting stored dust limit
    maxStoredDustLimit = 225, -- (conversion) (right column bottom) max stored dust limit
    fusionDustCost = 100, -- (fusion) dust cost
    transferDustCost = 100, -- (transfer) dust cost
    fusionBaseSuccessRate = 50, -- (fusion) base success rate
    fusionBonusSuccessRate = 15, -- (fusion) bonus success rate
    fusionReducedTierLossChance = 50, -- (fusion) tier loss chance after reduction
    vipBonus = 5    -- % bonus VIP (custom)
}

local forgeBonuses = {
    -- NOTE: actual rates are unknown and are difficult to measure due to the prices
    -- bonuses possible to roll on fusion success
    -- [bonus type] = chance points
    -- percent chance will be calculated based on sum of all entries
    -- (if chance points 1 and sum of all is 10, one point will be 10% chance)
    -- default config counts 100 as 1%
    [FORGE_BONUS_NONE] = 7500,
    [FORGE_BONUS_DUSTKEPT] = 500, -- dust not consumed
    [FORGE_BONUS_CORESKEPT] = 500, -- cores not consumed
    [FORGE_BONUS_GOLDKEPT] = 500, -- gold not consumed
    [FORGE_BONUS_ITEMKEPT_ONETIERLOST] = 250, -- item not consumed, lost 1 tier only
    [FORGE_BONUS_ITEMKEPT_NOTIERLOST] = 250, -- second item and its tier kept
    [FORGE_BONUS_BOTHUPGRADED] = 250, -- both items gained tier
    [FORGE_BONUS_EXTRATIER] = 250, -- item gained two tiers
    [FORGE_BONUS_ITEMNOTCONSUMED] = 0, -- item not consumed
} 
--
-- END CONFIG
--

-- register fusion total chance
local totalChance = 0
for _, chance in pairs(forgeBonuses) do
    totalChance = totalChance + chance
end
forgeBonuses.totalChance = totalChance

-- getters for the tables
function getForgeMeta()
    return forgeMeta
end
function getForgeData()
    return forgeData
end
function getForgeBonuses()
    return forgeBonuses
end

-- forge history manager
local function shortenCost(str)
    return str:reverse():gsub("000", "k"):reverse()
end

-- creature id (number), details (table depending on action type)
function appendForgeHistory(cid, details)
    local player = Player(cid)
    if (not player) then return false end

    local successfulString = details.success and 'Successful' or 'Failed'
    local detailsResponse = ''
    if details.action == FORGE_ACTION_FUSION then
        if details.success then
            detailsResponse = string.format([[
                %s <br><br>
                Fusion partners:
                <ul> 
                    <li>
                        First item: %s %s, tier %d
                    </li>
                    <li>
                        Second item: %s %s, tier %d
                    </li>
                </ul>
            
                <br>
                Result:
                <ul> 
                    <li>
                        First item: %s %s, tier + 1
                    </li>
                    <li>
                        Second item: %s %s, %sconsumed
                    </li>
                </ul>
            
                <br>
                Invested:
                <ul> 
                    <li>
                        %d dust
                    </li>
                    <li>
                        %d cores
                    </li>
                    <li>
                        %s gold
                    </li>
                </ul>
            
             ]], successfulString, details.article, details.itemA, details.tier, details.item2.article, details.item2.name, details.item2.tier, details.article, details.itemA, details.item2.article, details.item2.name, details.keepSecond and 'not ' or '', details.dustCost, details.coresCost, shortenCost(tostring(details.cost)))
        else 

            detailsResponse = string.format([[
                %s <br><br>
                Fusion partners:
                <ul> 
                    <li>
                        First item: %s %s, tier %d
                    </li>
                    <li>
                        Second item: %s %s, tier %d
                    </li>
                </ul>
            
                <br>
                Result:
                <ul> 
                    <li>
                        First item: %s %s, tier %d
                    </li>
                    <li>
                        Second item: %s %s, %sconsumed
                    </li>
                </ul>
            
                <br>
                Invested:
                <ul> 
                    <li>
                        %d dust
                    </li>
                    <li>
                        %d cores
                    </li>
                    <li>
                        %s gold
                    </li>
                </ul>
            
             ]], successfulString, details.article, details.itemA, details.tier, details.item2.article, details.item2.name, details.item2.tier, details.article, details.itemA, details.tier, details.item2.article, details.item2.name, details.keepSecond and 'not ' or '', details.dustCost, details.coresCost, shortenCost(tostring(details.cost)))
        end         

    elseif details.action == FORGE_ACTION_TRANSFER then

        detailsResponse = string.format([[
            %s <br><br>
            Transfer partners:
            <ul> 
                <li>
                    First item: %s %s, tier %d
                </li>
                <li>
                    Second item: %s %s, tier %d
                </li>
            </ul>
        
            <br>
            Result:
            <ul> 
                <li>
                    First item: %s %s, tier 0
                </li>
                <li>
                    Second item: %s %s, tier %d
                </li>
            </ul>
        
            <br>
            Invested:
            <ul> 
                <li>
                    100 dusts
                </li>
                <li>
                    1 core
                </li>
                <li>
                    %s gold
                </li>
            </ul>
        
        ]], successfulString, details.article, details.itemA, details.tier, details.item2.article, details.item2.name, details.item2.tier, details.article, details.itemA, details.item2.name, details.item2.tier, (details.tier - 1), shortenCost(tostring(details.cost)))

    elseif details.action == FORGE_ACTION_DUSTTOSLIVERS then
        detailsResponse = string.format("%s %d dust to %d slivers.", successfulString, details.cost, details.gained)

    elseif details.action == FORGE_ACTION_SLIVERSTOCORES then
        details.action = FORGE_ACTION_CONVERSION
        detailsResponse = string.format("%s %d slivers to %d cores.", successfulString, details.cost, details.gained)

    elseif details.action == FORGE_ACTION_INCREASELIMIT then
        details.action = FORGE_ACTION_CONVERSION
       -- detailsResponse = string.format("%s Dust limit: %d -> %d, Cost: %d", successfulString, details.gained, details.gained + 1, details.cost)
       detailsResponse = string.format("Spent %d dust to increase the dust limit to %d.", details.cost, details.gained + 1)

    else
        detailsResponse = "(unknown)"
    end
    
    local info = {
        actionType = details.action,
        description = detailsResponse,
        success = details.success and 1 or 0,           
        bonus = details.bonus ~= 0 and details.bonus or 0,            
        cost = details.cost ~= 0 and details.cost or 0,            
        gained = details.gained ~= 0 and details.gained or 0            
    }

    -- info.actionType, db.escapeString(info.description), os.time(), info.success, info.bonus)

    ForgeHistoryCheckTime:appendLogForgeHistory(player, info)
end

--[[
CREATE TABLE `forge_system_history` (
  `player_id` int NOT NULL,
  `action_type` int NOT NULL DEFAULT 0,
  `description` text NOT NULL,
  `success` tinyint NOT NULL DEFAULT 0,  
  `bonus` tinyint NOT NULL DEFAULT 0,  
  `done_at` bigint NOT NULL,
  `done_at_date` datetime DEFAULT NOW(),
  FOREIGN KEY (`player_id`) REFERENCES `players` (`id`) ON DELETE CASCADE
) ENGINE='InnoDB';
]]--

function ForgeHistoryCheckTime:loadForgeHistoryFromDb(player)
    if (player) then 
        local playerGuid = player:getGuid()
        local query = string.format('SELECT * FROM `forge_system_history` WHERE `player_id` = %d ORDER BY `done_at`;', playerGuid)
        local resultId = db.storeQuery(query)
        local data = {}
        if (resultId) then 
            data.nextRefreshTime = os.time() + self.timeToRefresh
            data.logs = {}
            repeat
                data.logs[#data.logs + 1] = {
                    action = result.getNumber(resultId, 'action_type'),
                    description = result.getString(resultId, 'description'),
                    done_at = result.getNumber(resultId, 'done_at'),
                    success = result.getNumber(resultId, 'success'),              
                    bonus = result.getNumber(resultId, 'bonus'),              
                    cost = result.getNumber(resultId, 'cost'),              
                    gained = result.getNumber(resultId, 'gained'),              
                }
            until not result.next(resultId)
            result.free(resultId)
        end

        self.players[playerGuid] = data
    end
end

function ForgeHistoryCheckTime:getForgeHistory(player)
    if (player) then 
        local playerGuid = player:getGuid()
        if (not self.players[playerGuid] or os.time() >= (self.players[playerGuid].nextRefreshTime or 0)) then 
            self:loadForgeHistoryFromDb(player)
        end 
        return self.players[playerGuid]
    end
end 

function ForgeHistoryCheckTime:appendLogForgeHistory(player, info)
    if (player) then 
        local query = string.format('INSERT INTO `forge_system_history` (`player_id`, `action_type`, `description`, `done_at`, `success`, `bonus`, `cost`, `gained`) VALUES (%d, %d, %s, %d, %d, %d, %d, %d)', player:getGuid(), info.actionType, db.escapeString(info.description), os.time(), info.success, info.bonus, info.cost, info.gained)
        db.asyncQuery(query)
    end
end

function getForgeHistory(cid)
    local player = Player(cid)
    if (not player) then return {} end
    return ForgeHistoryCheckTime:getForgeHistory(player)
end

-- load forge config for this file
local forgeMeta = getForgeMeta()
local forgeData = getForgeData()
--local forgeOrder = getForgeOrder()

-- forge resource methods

-- dust
function Player:getForgeDust()
    local total = math.max(0, self:getStorageValue(FORGE_DUST_STORAGE))
    return total
    
    -- alternative version (if you decide to do dust as item):
    -- return self:getItemCount(ITEM_FORGE_DUST)
end

function Player:setForgeDust(amount, toRemove)
    if (amount < 1) then 
        return self:setStorageValue(FORGE_DUST_STORAGE, 0)
    end 
    if (not toRemove and amount >= forgeData.maxStoredDustLimit) then 
        return false
    end
    return self:setStorageValue(FORGE_DUST_STORAGE, amount)
end

function Player:addForgeDust(amount)
    local myLimit = self:getForgeDustLimit()
    local totalAmount = math.min(myLimit, (self:getForgeDust() + amount))
    
    return self:setForgeDust(totalAmount, false)  
end

function Player:removeForgeDust(amount)
    local totalDusts = self:getForgeDust()
    local result = totalDusts-amount
    return self:setForgeDust(result, true)    
    -- alternative version:
    -- return self:addItem(ITEM_FORGE_DUST, amount)
end

-- dust level
function Player:getForgeDustLevel()
    return math.max(0, self:getStorageValue(STORAGE_FORGE_DUST_LEVEL))
end

function Player:setForgeDustLevel(level)
    return self:setStorageValue(STORAGE_FORGE_DUST_LEVEL, level)
end

function Player:getForgeDustLimit()
    return math.min(forgeData.maxStoredDustLimit, forgeData.minStoredDustLimit + self:getForgeDustLevel())
end

-- slivers
function Player:getSlivers()
    return self:getItemCount(ITEM_FORGE_SLIVERS)
end

function Player:addSlivers(amount)
    return self:addItem(ITEM_FORGE_SLIVERS, amount)
end

function Player:removeSlivers(amount)
    return self:removeItem(ITEM_FORGE_SLIVERS, amount)
end

-- cores
function Player:getForgeCores()
    return self:getItemCount(ITEM_FORGE_CORES)
end

function Player:addForgeCores(amount)
    return self:addItem(ITEM_FORGE_CORES, amount)
end

function Player:removeForgeCores(amount)
    return self:removeItem(ITEM_FORGE_CORES, amount)
end

-- item check passed, perform the action
local forgeBonuses = getForgeBonuses()
local function rollBonus() 
    local checkChance = 0
    local totalChance = forgeBonuses.totalChance
    local roll = math.random(totalChance)
    
    for index, chance in pairs(forgeBonuses) do
        if tonumber(index) and chance ~= 0 then
            checkChance = checkChance + chance
            if roll < checkChance then
                return index
            end
        end
    end
end

---- FUSION
function Player:fuseItems(item1, item2, usesSuccessRateCore, usesTierLossCore, cost)
    local tier = item1:getTier()
    local forgeResultData = {
        action = FORGE_ACTION_FUSION,
        success = false,
        tierLoss = false,
        itemA = item1:getName(),
        tier = tier,
        article = item1:getArticle(),
        successCore = usesSuccessRateCore > 0,
        tierCore = usesTierLossCore > 0,
        bonus = 0,
        cost = 0,
        dustCost = 0,
        coresCost = 0,
        item2 = {
            tier = item2:getTier(),
            name = item2:getName(),
            article = item2:getArticle()
        }
    }

    if self:getFreeCapacity() < ItemType(ITEM_FORGE_CHEST):getWeight() then
        -- no cap to carry the chest with forge output
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHCAP)    
    end
    
    local playerBP = self:getSlotItem(CONST_SLOT_BACKPACK)
    if not playerBP or playerBP:getEmptySlots(true) < 1 then
        -- unable to carry the chest
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHROOM)   
    end

    -- roll bonus
    local bonusType = rollBonus(FORGE_ACTION_FUSION)
    
    -- roll result
    local successChance = forgeData.fusionBaseSuccessRate
	
    if usesSuccessRateCore > 0 then
		if self:isVip() then -- Custom System VIP
			successChance = successChance + forgeData.fusionBaseSuccessRate + forgeData.vipBonus
		else
			successChance = successChance + forgeData.fusionBonusSuccessRate
		end
    end

    -- generate chest
    local chest = Game.createItem(ITEM_FORGE_CHEST)
    
    -- get values to work with
    local clientId = item1:getType():getClientId()
    local coresCost = (usesSuccessRateCore > 0 and 1 or 0) + (usesTierLossCore > 0 and 1 or 0)
        
    --  forge data for output message
    local params = {
        startClientId = clientId,
        startTier = tier,
        outputClientId = clientId,
        outputTier = 0,
        bonusType = 0,
        bonusClientId = clientId,
        bonusTier = 0,
        coresCost = coresCost
    }
    
    ---- fusion successful
    if (math.random(100) < successChance) then
        item1:setTier(tier + 1)
        
        -- apply rolled bonus
        local keepSecond = false
        local bonusTier = 0
        if bonusType == FORGE_BONUS_ITEMKEPT_ONETIERLOST then
            if tier > 0 then
                bonusTier = tier - 1
                item2:setTier(bonusTier)
                keepSecond = true
            else
                -- unable to apply this bonus
                -- remove it from post fusion notification
                bonusType = FORGE_BONUS_NONE
            end
        elseif bonusType == FORGE_BONUS_ITEMKEPT_NOTIERLOST then
            bonusTier = tier
            keepSecond = true
        elseif bonusType == FORGE_BONUS_BOTHUPGRADED then
            bonusTier = tier + 1
            item2:setTier(bonusTier)
            keepSecond = true               
        elseif bonusType == FORGE_BONUS_EXTRATIER then
            if tier+2 <= #forgeMeta[item1:getClassification()] then
                bonusTier = tier + 2
                item1:setTier(bonusTier)
            else
                -- unable to apply this bonus
                -- remove it from post fusion notification
                bonusType = FORGE_BONUS_NONE
            end
        elseif bonusType == FORGE_BONUS_ITEMNOTCONSUMED then
            bonusTier = tier
            keepSecond = true
        end
        
        -- register output tier
        params.bonusType = bonusType
        params.outputTier = tier + 1
        params.bonusTier = bonusTier
        
        -- move items to chest
        item1:moveTo(chest)
        if keepSecond then -- << quando nao quebra o segundo item
            item2:moveTo(chest)
        else
            item2:remove()
        end
        self:addItemEx(chest)
        
        -- consume resources
        if bonusType ~= FORGE_BONUS_DUSTKEPT then
            forgeResultData.dustCost = forgeData.fusionDustCost
            self:removeForgeDust(forgeData.fusionDustCost)
        end
        if bonusType ~= FORGE_BONUS_CORESKEPT then
            forgeResultData.coresCost = coresCost
            self:removeForgeCores(coresCost)
        end
        if bonusType ~= FORGE_BONUS_GOLDKEPT then
            forgeResultData.cost = cost
            self:removeMoney(cost)
        end
        
        -- log forge action
        forgeResultData.success = true
        forgeResultData.bonus = bonusType -- print 0 (ok)
        forgeResultData.keepSecond = keepSecond
        appendForgeHistory(self:getId(), forgeResultData)
		
        --player:say(player:getName() .. " successfully fused a " .. item1:getName() .. " with tier " .. item1:getTier() .. " with a ".. item1:getName() .."", TALKTYPE_MONSTER_SAY, false, nil, Position(32209, 32278, 7))


		
        -- send fusion animation
        self:sendForgeResult(FORGE_ACTION_FUSION, FORGE_RESULT_SUCCESS, params)
        return
    end

    ---- fusion failed
    -- roll tier loss
    local isTierLost = math.random(100) < (usesTierLossCore > 0 and forgeData.fusionReducedTierLossChance or 100)
    local keepSecond = false
    params.outputTier = tier + 1
    
    if (isTierLost) then
        local newTier = tier - 1
        if newTier >= 0 then
            item2:setTier(newTier)
            keepSecond = true
        end
    else
        forgeResultData.tierLossPrevented = true
        params.bonusType = FORGE_BONUS_ITEMNOTCONSUMED
        params.bonusTier = tier
        keepSecond = true
    end
    
    -- move items to chest
    item1:moveTo(chest)
    if keepSecond then
        item2:moveTo(chest)
    else
        item2:remove()
    end
    self:addItemEx(chest)
    
    -- consume resources
    self:removeForgeDust(forgeData.fusionDustCost)
    self:removeForgeCores(coresCost)
    self:removeMoney(cost)
    
    -- log forge action
    forgeResultData.dustCost = forgeData.fusionDustCost
    forgeResultData.coresCost = coresCost
    forgeResultData.cost = cost
    appendForgeHistory(self:getId(), forgeResultData)
        
    -- send fusion animation
    self:sendForgeResult(FORGE_ACTION_FUSION, FORGE_RESULT_FAILURE, params)
    return
end

---- TRANSFER
function Player:transferTier(item1, item2, cost)
    -- NOTE: no bonuses for transfer
    -- NOTE: transfer is always successful (100% chance)
    local tier = item1:getTier()
    local forgeResultData = {
        action = FORGE_ACTION_TRANSFER,
        success = true,
        itemA = item1:getName(),
        article = item1:getArticle(),
        itemB = item2:getName(),
        tier = tier,
        cost = cost,
        item2 = {
            tier = item2:getTier(),
            name = item2:getName(),
            article = item2:getArticle()
        }        
    }
    
    if self:getFreeCapacity() < ItemType(ITEM_FORGE_CHEST):getWeight() then
        -- no cap to carry the chest with forge output
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHCAP)     
        return
    end
    
    local playerBP = self:getSlotItem(CONST_SLOT_BACKPACK)
    if not playerBP or playerBP:getEmptySlots(true) < 1 then
        -- unable to carry the chest
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHROOM)   
        return
    end
    
    -- generate chest
    local chest = Game.createItem(ITEM_FORGE_CHEST)
    
    --  forge data for output message
    local params = {
        startClientId = item1:getType():getClientId(),
        startTier = tier,
        outputClientId = item2:getType():getClientId(),
        outputTier = tier - 1,
        bonusType = 0,
    }
    
    -- transfer the tier
    item1:setTier(0)
    item2:setTier(tier - 1)
    item1:moveTo(chest)
    item2:moveTo(chest)
    self:addItemEx(chest)
    
    -- consume resources
    self:removeForgeDust(forgeData.transferDustCost)
    self:removeForgeCores(1)
    self:removeMoney(cost)
    
    -- log forge action
    appendForgeHistory(self:getId(), forgeResultData)
    
    -- send animation
    self:sendForgeResult(FORGE_ACTION_TRANSFER, FORGE_RESULT_SUCCESS, params)
end


-- forge search
local function fusionSearch(item, itemId, tier)
    local mainCondition = item:getId() == itemId and item:getTier() == tier
    if not forgeData.allowCustomItemFusion then
        mainCondition = mainCondition and item:isMarketable()
    end
    
    return mainCondition
end

local function transferSearch(item, itemId, tier)
    local mainCondition = item:getId() == itemId and item:getTier() == tier
    if not forgeData.allowCustomItemTransfer then
        mainCondition = mainCondition and item:isMarketable()
    end
    
    return mainCondition
end

-- queryFunc(item) - function that will be used for search
-- count to find
function Container:getItemsByQuery(count, queryFunc, ...)
    local response = {}
    local resultingCount = 0
    if count == 0 then
        return response, resultingCount
    end
    
    for _, item in pairs(self:getItems(true)) do
        if queryFunc(item, ...) then
            response[#response + 1] = item
            resultingCount = resultingCount + 1 --item:getCount() if stackables get classes in the future
        end
        
        if resultingCount >= count then
            return response, resultingCount
        end
    end
    
    return response, resultingCount
end

-- player requests processors

---- FUSION
function Player:onFusionRequest(clientId, tier, targetClientId, usesSuccessRateCore, usesTierLossCore)
    if clientId ~= targetClientId then
        -- bad request (fusion has to be two identical items)
        self:sendDefaultForgeError(FORGE_ERROR_BADREQUEST)
        return
    end

    -- check if player has bp
    local playerBP = self:getSlotItem(CONST_SLOT_BACKPACK)
    if not playerBP then
        -- player lost his backpack
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHITEMS)
    end
    
    -- check if item type exists
    local itemType = Game.getItemTypeByClientId(clientId)
    if not itemType then
        -- bad request (client id does not match any item)
        self:sendDefaultForgeError(FORGE_ERROR_BADREQUEST)
        return
    end
    
    -- check if item class is eligible
    local class = itemType:getClassification()
    if class == 0 or class > #forgeMeta then
        -- selected item has unsupported classification
        self:sendDefaultForgeError(FORGE_ERROR_NOTUPGRADEABLE)
        return
    end
    
    -- check if tier can be upgraded
    if tier >= #forgeMeta[class] then
        -- tier too high to upgrade
        self:sendDefaultForgeError(FORGE_ERROR_TIERTOOHIGH)
        return
    end
    
    -- check if player has required resources
    local cost = forgeMeta[class][tier+1]
    local MoneyTotal = (self:getMoney() + self:getBankBalance())
    if MoneyTotal < cost then
        -- not enough gold
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHGOLD)
        return
    end
    if self:getForgeDust() < forgeData.fusionDustCost then
        -- not enough dust
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHDUST)
        return
    end
    if self:getForgeCores() < usesSuccessRateCore + usesTierLossCore then
        -- selected cores not available
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHCORES)
        return
    end

    -- check if player is near the forge
    if not self:isInForge() then
        -- player is not close enough to the forge
        self:sendDefaultForgeError(FORGE_ERROR_NOTINFORGE)
        return
    end
    
    -- iterate player containers to find items
    local itemsForFusion, itemCount = playerBP:getItemsByQuery(2, fusionSearch, itemType:getId(), tier)
    if itemCount >= 2 then
        -- items found, perform the fusion
        self:fuseItems(itemsForFusion[1], itemsForFusion[2], usesSuccessRateCore, usesTierLossCore, cost)
    end
end

---- TRANSFER
function Player:onForgeTransferRequest(clientId, tier, targetClientId)
    -- check if tier can be transfered
    if tier < 2 then 
        -- selected item has unsupported tier
        self:sendDefaultForgeError(FORGE_ERROR_NOTUPGRADEABLE)
        return
    end
    
    -- check if player has bp
    local playerBP = self:getSlotItem(CONST_SLOT_BACKPACK)
    if not playerBP then
        -- player lost his backpack
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHITEMS)
        return
    end
    
    -- check if item types exist
    local fromItem = Game.getItemTypeByClientId(clientId)
    local toItem = Game.getItemTypeByClientId(targetClientId)
    if not (fromItem and toItem) then
        -- bad request (one of client ids does not match any item)
        self:sendDefaultForgeError(FORGE_ERROR_BADREQUEST)
        return
    end
    
    -- check if item classes are eligible
    local fromClass = fromItem:getClassification()
    if fromClass ~= toItem:getClassification() then
        -- classes do not match
        self:sendDefaultForgeError(FORGE_ERROR_NOTUPGRADEABLE)
        return
    end
    if fromClass == 0 or fromClass > #forgeMeta then
        -- selected items have unsupported classification
        self:sendDefaultForgeError(FORGE_ERROR_NOTUPGRADEABLE)
        return
    end
    
    -- check if player has required resources
    local cost = forgeMeta[fromClass][tier]
    local MoneyTotal = (self:getMoney() + self:getBankBalance())
    if MoneyTotal < cost then
        -- not enough gold
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHGOLD)
        return
    end
    if self:getForgeDust() < forgeData.transferDustCost then
        -- not enough dust
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHDUST)
        return
    end
    if self:getForgeCores() < 1 then -- transfer always costs 1 core
        -- not enough cores
        self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHCORES)
        return
    end

    -- check if player is near the forge
    if not self:isInForge() then
        -- player is not close enough to the forge
        self:sendDefaultForgeError(FORGE_ERROR_NOTINFORGE)
        return
    end
    
    -- find the items
    local transferItems, itemCount = playerBP:getItemsByQuery(1, transferSearch, fromItem:getId(), tier) 

    if (itemCount >= 1) then
        local targetItems, targetItemCount = playerBP:getItemsByQuery(1, transferSearch, toItem:getId(), 0)
        if (targetItemCount >= 1) then
            -- start the transfer
            self:transferTier(transferItems[1], targetItems[1], cost)
            return
        end
    end
    
    -- items not found
    self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHITEMS)
    return
end

function Player:onResourceConversion(forgeAction)
    local forgeResultData = {
        action = forgeAction,
        success = true
    }
    
    if forgeAction == FORGE_ACTION_DUSTTOSLIVERS then
        -- price check
        local cost = forgeData.sliversDustCost * forgeData.sliversPerConversion
        local dust = self:getForgeDust()
        if cost > dust then
            return self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHDUST)
        end

        -- conversion (dust to slivers)
        if self:addSlivers(forgeData.sliversPerConversion) then
            self:removeForgeDust(cost)
            self:sendResourceBalance(RESOURCE_FORGE_DUST, dust - cost)
            self:sendResourceBalance(RESOURCE_FORGE_SLIVERS, self:getSlivers())
        end
        
        -- info for action logging
        forgeResultData.cost = cost
        forgeResultData.gained = forgeData.sliversPerConversion
    elseif forgeAction == FORGE_ACTION_SLIVERSTOCORES then
        -- price check
        local slivers = self:getSlivers()
        local cost = forgeData.coreSliversCost
        if cost > slivers then
            return self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHSLIVERS)
        end
        
        -- conversion (slivers to cores)
        if self:addForgeCores(1) then
            self:removeSlivers(cost)
            self:sendResourceBalance(RESOURCE_FORGE_SLIVERS, slivers - cost)
            self:sendResourceBalance(RESOURCE_FORGE_CORES, self:getForgeCores())
        end
        
        -- info for action logging
        forgeResultData.cost = cost
        forgeResultData.gained = 1
    else --if forgeAction == FORGE_ACTION_INCREASELIMIT then
        -- max level check
        local playerDustLevel = self:getForgeDustLevel()
        if forgeData.minStoredDustLimit + playerDustLevel >= forgeData.maxStoredDustLimit then
            return self:sendDefaultForgeError(FORGE_ERROR_MAXDUSTLEVELREACHED)
        end
        
        -- integrity check
        local upgradeCost = self:getForgeDustLimit() - forgeData.dustLimitIncreaseCost
        if upgradeCost < 0 then
            return self:sendDefaultForgeError(FORGE_ERROR_BADLEVELINCREASEPRICE)
        end
        
        -- price check
        local dust = self:getForgeDust()
        if upgradeCost > dust then
            return self:sendDefaultForgeError(FORGE_ERROR_NOTENOUGHDUST)
        end
                    
        -- upgrade
        self:removeForgeDust(upgradeCost)
        self:setForgeDustLevel(playerDustLevel + 1)
        local cid = self:getId()
        sendForgeUI(cid, true)
        self:sendResourceBalance(RESOURCE_FORGE_DUST, dust - upgradeCost)
        
        -- info for action logging
        forgeResultData.cost = upgradeCost
        forgeResultData.gained = forgeData.minStoredDustLimit + playerDustLevel
    end
    
    -- log forge action 
    appendForgeHistory(self:getId(), forgeResultData)
end

-- forge check
function Player:isInForge()
    local playerPos = self:getPosition()
    for deltaX = -1, 1 do
        for deltaY = -1, 1 do
            local pos = Position(playerPos.x + deltaX, playerPos.y + deltaY, playerPos.z)
            local tile = Tile(pos)
            if tile then
                for _, item in pairs(tile:getItems()) do
                    local itemId = item:getType():getId()
                    if itemId >= ITEM_FORGE_PLACE_FIRST and itemId <= ITEM_FORGE_PLACE_LAST then
                        return true
                    end
                end
            end
        end
    end    
    return false
end

-- cache forge ui to reduce about of operations during dust limit upgrades
function NetworkMessage:addAndCacheForgeValue(cid, value, varType)
    ForgeCache[cid][#ForgeCache[cid] + 1] = {value, varType}
    if varType == FORGE_CACHE_TYPE_BYTE then
        self:addByte(value)
    elseif varType == FORGE_CACHE_TYPE_U16 then
        self:addU16(value)
    else
        print("ERROR: Variable type not supported")
    end
end

local BYTES = {
    -- from client
    FORGE_REQUEST_USEFORGE = 0xBF, -- fuse/transfer/convert
    FORGE_REQUEST_HISTORY = 0xC0, -- request forge history

    -- from server
    FORGE_RESPONSE_BASE = 0x87, -- forge window
    FORGE_RESPONSE_META = 0x86, -- forge metadata (classes, tiers, chances, costs)
    FORGE_RESPONSE_HISTORY = 0x88, -- forge actions history / to do
    FORGE_RESPONSE_EXIT = 0x89, -- close forge UI (no more bytes required)
    FORGE_RESPONSE_RESULT = 0x8A, -- fusion/transfer result
}

function onRecvbyte(player, msg, byte)
    if not player then 
        return false 
    end     

    if (byte == BYTES.FORGE_REQUEST_USEFORGE) then
        local forgeAction = msg:getByte()      
        -- fusion
        if forgeAction == FORGE_ACTION_FUSION then
            player:onFusionRequest(
                msg:getU16(), -- from item
                msg:getByte(), -- from item tier
                msg:getU16(), -- to item (not needed technically)
                msg:getByte(), -- increase success chance
                msg:getByte() -- reduce tier loss
            )
            return
            
        -- transfer
        elseif forgeAction == FORGE_ACTION_TRANSFER then
            player:onForgeTransferRequest(
                msg:getU16(), -- from item
                msg:getByte(), -- from item tier
                msg:getU16() -- to item
            )
            return

        -- convert resources
        elseif forgeAction <= FORGE_ACTION_INCREASELIMIT then
            if player:isInForge() then
                player:onResourceConversion(forgeAction)
            else
                player:sendDefaultForgeError(FORGE_ERROR_NOTINFORGE)
                return
            end

            return
        end
            
        -- bad request
        player:sendDefaultForgeError(FORGE_ERROR_BADREQUEST)
        return
    end

    -- request history
    -- send history + forge resources
    --[[
    request history (both sources):
        192
        0 (?)
        0 (page?)
        9 (entries per page?)
    ]]
    player:sendForgeHistory(msg:getByte())
    
    --print(recvbyte, message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte(), message:getByte())
    sendItemClasses(playerGuid)
    sendForgeUI(player:getId(), false)
end

---- send methods
-- forge resources
function Player:sendForgeResources()
    self:sendResourceBalance(RESOURCETYPE_BANK_GOLD, self:getBankBalance())
    self:sendResourceBalance(RESOURCETYPE_INVENTORY_GOLD, self:getMoney())
    self:sendResourceBalance(RESOURCE_FORGE_DUST, self:getForgeDust())
    self:sendResourceBalance(RESOURCE_FORGE_SLIVERS, self:getSlivers())
    self:sendResourceBalance(RESOURCE_FORGE_CORES, self:getForgeCores())
end

-- error handler
local errorMsgs = {
    [FORGE_ERROR_NOTENOUGHGOLD] = "Not enough gold.",
    [FORGE_ERROR_NOTENOUGHDUST] = "Not enough dust.",
    [FORGE_ERROR_NOTENOUGHSLIVERS] = "Not enough slivers.",
    [FORGE_ERROR_NOTENOUGHCORES] = "Not enough exaltation cores.",
    [FORGE_ERROR_NOTENOUGHITEMS] = "You do not have necessary items.",
    [FORGE_ERROR_NOTENOUGHCAP] = "Not enough capacity.",
    [FORGE_ERROR_NOTENOUGHROOM] = "Not enough room.",
    [FORGE_ERROR_NOTUPGRADEABLE] = "Selected items cannot be processed.",
    [FORGE_ERROR_MAXDUSTLEVELREACHED] = "Maximum level reached.",
    [FORGE_ERROR_BADLEVELINCREASEPRICE] = "Bad forge system configuration. Please contact server administrator.",
    [FORGE_ERROR_TIERTOOHIGH] = "Maximal tier reached.",
    [FORGE_ERROR_NOTINFORGE] = "Stand near forge to perform this action.",
    [FORGE_ERROR_BADREQUEST] = "Unable to process your request.",
}
function Player:sendDefaultForgeError(errorCode)
    self:closeForgeUI() -- escape forge dialog

    errorCode = errorCode or 0
    local errorMsg = errorMsgs[errorCode] or "(unknown error code)"
    self:popupFYI(string.format("Error: %s", errorMsg))
end

local function parseForgeItemType(t, itemType, itemId, count, class, tier)
    if not t[class] then
        t[class] = {}
    end
    
    if (count > 0) then
        t[class][itemId + tier * ITEMTIER_HASH] = count
    end
    return
end

-- base UI
function sendForgeUI(cid, loadFromCache)
    -- FUSION
    -- collect item data for fusion    
    local player = Player(cid)
    if (not player) then return false end
    player:sendForgeResources() -- recarrega 
    
    if loadFromCache and ForgeCache[cid] then
        if #ForgeCache[cid] > 0 then
            local m = NetworkMessage()
            m:addByte(BYTES.FORGE_RESPONSE_BASE)
            
            -- read cached bytes
            for i = 1, #ForgeCache[cid] do
                local cachedValue = ForgeCache[cid][i]
                if cachedValue[2] == FORGE_CACHE_TYPE_BYTE then
                    m:addByte(cachedValue[1])
                elseif cachedValue[2] == FORGE_CACHE_TYPE_U16 then
                    m:addU16(cachedValue[1])
                -- elseif ... then
                -- more types
                end
            end
            
            m:addByte(player:getForgeDustLimit())
            m:sendToPlayer(player)
            return
        end
    end
    
    -- tables fill memory in Lua fast so
    -- I recommend clearing it also when the player is walking through forge area entrance, logging out or dying
    ForgeCache[cid] = {}
    
    local playerItems = player:getItemsByLocation(LOCATION_BACKPACK, not forgeData.allowCustomItemFusion)
    local fusionItems = {}
    local fusionItemsCount = 0
    for itemInfo, count in pairs(playerItems) do
        -- you need 2 items in order for them to be displayed
        if count > 1 then
            local itemId, tier = unhashItemInfo(itemInfo)
            local itemType = ItemType(itemId)
            local class = itemType:getClassification() -- teste 48 pra igualar a class
            if class > 0 and forgeMeta[class] and tier < #forgeMeta[class] then
                fusionItems[itemInfo] = count
                fusionItemsCount = fusionItemsCount + 1
            end
        end
    end
    
    -- TRANSFER
    -- collect item data for transfer
    local playerItemsToTransfer
    if forgeData.allowCustomItemFusion == forgeData.allowCustomItemTransfer then
        playerItemsToTransfer = playerItems
    else
        playerItemsToTransfer = player:getItemsByLocation(LOCATION_BACKPACK, not forgeData.allowCustomItemTransfer)
    end
    
    local donors = {} -- items player moves the tier from       
    local recipents = {} -- items player moves the tier to
    
    for itemInfo, count in pairs(playerItemsToTransfer) do
        local itemId, tier = unhashItemInfo(itemInfo)
        local itemType = ItemType(itemId)
        local class = itemType:getClassification()
        
        if class > 0 then -- classless items are ignored by the client ui
            if tier == 0 then -- recipents can be tier zero only
                parseForgeItemType(recipents, itemType, itemId, count, class, tier)

            -- donors need to be tier 2 at least because tier gets lowered by 1 during transform
            elseif tier > 1 and forgeMeta[class] and tier <= #forgeMeta[class] then 
                parseForgeItemType(donors, itemType, itemId, count, class, tier)
            end
        end
    end

    local transferGroupsCount = 0
    for _, categoryData in pairs(donors) do
        transferGroupsCount = transferGroupsCount + 1
    end

    -- RESPONSE
    -- start the packet
    local m = NetworkMessage()
    m:addByte(BYTES.FORGE_RESPONSE_BASE) -- header
    
    -- fusion tab
    m:addAndCacheForgeValue(cid, fusionItemsCount, FORGE_CACHE_TYPE_U16)
    for itemInfo, count in pairs(fusionItems) do
        local itemId, tier = unhashItemInfo(itemInfo)
        m:addAndCacheForgeValue(cid, 1, FORGE_CACHE_TYPE_BYTE) -- number of "friend" items (unused)
        -- 1 item to send:
        m:addAndCacheForgeValue(cid, ItemType(itemId):getClientId(), FORGE_CACHE_TYPE_U16)
        m:addAndCacheForgeValue(cid, tier, FORGE_CACHE_TYPE_BYTE)
        m:addAndCacheForgeValue(cid, math.min(count, 0xFFFF), FORGE_CACHE_TYPE_U16)
    end

    -- transfer tab
    m:addAndCacheForgeValue(cid, transferGroupsCount, FORGE_CACHE_TYPE_BYTE)
    if transferGroupsCount > 0 then
        for class, items in pairs(donors) do
            local itemCount = 0
            for _, v in pairs(items) do
                itemCount = itemCount + 1
            end
            
            -- potential donors
            m:addAndCacheForgeValue(cid, itemCount, FORGE_CACHE_TYPE_U16)
            for itemInfo, count in pairs(items) do
                local itemId, tier = unhashItemInfo(itemInfo)
                m:addAndCacheForgeValue(cid, ItemType(itemId):getClientId(), FORGE_CACHE_TYPE_U16)
                m:addAndCacheForgeValue(cid, tier, FORGE_CACHE_TYPE_BYTE)
                m:addAndCacheForgeValue(cid, math.min(count, 0xFFFF), FORGE_CACHE_TYPE_U16)
            end
            
            -- potential recipents
            local recipentsCount = 0
            if recipents[class] then
                for k, v in pairs(recipents[class]) do
                    recipentsCount = recipentsCount + 1
                end
            end
            
            m:addAndCacheForgeValue(cid, recipentsCount, FORGE_CACHE_TYPE_U16)
            if recipentsCount > 0 then
                for itemId, count in pairs(recipents[class]) do
                    m:addAndCacheForgeValue(cid, ItemType(itemId):getClientId(), FORGE_CACHE_TYPE_U16)
                    m:addAndCacheForgeValue(cid, math.min(count, 0xFFFF), FORGE_CACHE_TYPE_U16)
                end
            end
        end
    end
    
    m:addByte(player:getForgeDustLimit())
    m:sendToPlayer(player)

    if not loadFromCache then
        player:sendForgeResources()
    end
end

function Player:sendDustLevelUpdate()
    local m = NetworkMessage()
    m:addByte(BYTES.FORGE_RESPONSE_BASE)
    m:addU16(0)
    m:addByte(0)
    m:addByte(self:getForgeDustLimit())
    m:sendToPlayer(self)
end

local bonusTypesWithItem = {
    FORGE_BONUS_ITEMKEPT_ONETIERLOST,
    FORGE_BONUS_ITEMKEPT_NOTIERLOST,
    FORGE_BONUS_BOTHUPGRADED,
    FORGE_BONUS_EXTRATIER,
    FORGE_BONUS_ITEMNOTCONSUMED
}

function Player:sendForgeResult(forgeAction, result, params) 
    self:closeForgeUI() -- escape forge dialog
    --[[
        local params = {
            startClientId = a,
            startTier = b,
            outputClientId = c,
            outputTier = d,
            bonusType = e,
            bonusClientId = f,
            bonusTier = g,
            coresCost = h
        }
    ]]
    -- don't display when cores were not used
    if params.bonusType == FORGE_BONUS_CORESKEPT and params.coresCost == 0 then
        params.bonusType = FORGE_BONUS_NONE
    end
    
    local m = NetworkMessage()
    m:addByte(BYTES.FORGE_RESPONSE_RESULT)    
    m:addByte(forgeAction) -- fusion or transfer
    m:addByte(result) -- isSuccess
    
    -- left side item
    m:addU16(params.startClientId)
    m:addByte(params.startTier)
    
    -- right side item
    m:addU16(params.outputClientId) 
    m:addByte(params.outputTier)
    
    -- rolled bonus
    -- 0x00 - nothing
    -- 0x01 - no dust consumed
    -- 0x02 - cores not consumed (requires extra byte: amount of cores)
    -- 0x03 - gold not consumed
    
    -- (values below require u16 clientId, u8 tier)
    -- 0x04 - item not consumed, lost 1 tier only
    -- 0x05 - you kept the second item and its tier
    -- 0x06 - both items gained extra tier
    -- 0x07 - item gained two tiers
    -- 0x08 - second item was not consumed
    m:addByte(params.bonusType) 
    if params.bonusType == FORGE_BONUS_CORESKEPT then
        m:addByte(params.coresCost)
    elseif table.contains(bonusTypesWithItem, params.bonusType) then
        m:addU16(params.bonusClientId)
        m:addByte(params.bonusTier)
    end

    m:sendToPlayer(self)
end

function Player:closeForgeUI()
    local m = NetworkMessage()
    m:addByte(BYTES.FORGE_RESPONSE_EXIT)
    m:sendToPlayer(self)
end

function Player:sendForgeHistory(page)
    page = page + 1 -- client starts index at 0
    
    local data = getForgeHistory(self:getId())
    local history = data.logs
    if not history then
        history = {}
    end
    
    local lastPage = math.max(1, math.floor((#history-1)/forgeData.historyEntriesPerPage)+1)
    local currentPage = math.min(page, lastPage)
    
    local historyToSend = {}
    for i = ((currentPage-1) * forgeData.historyEntriesPerPage)+1, math.min(#history, currentPage * forgeData.historyEntriesPerPage) do
        historyToSend[#historyToSend + 1] = history[i]
    end
    
    local response = NetworkMessage()
    response:addByte(BYTES.FORGE_RESPONSE_HISTORY)
    response:addU16(currentPage-1)
    response:addU16(lastPage)
    response:addByte(#historyToSend)
    if #historyToSend > 0 then
        for i = 1, #historyToSend do
            response:addU32(historyToSend[i].done_at)
            response:addByte(historyToSend[i].action)
            response:addString(historyToSend[i].description)
            --print("historyToSend[i].bonus", historyToSend[i].bonus) -- esse bonus precisa ser 0 quando no  applied bonus (quando keep gold coin, core ou dust)
            response:addByte(historyToSend[i].bonus >= 1 and 0x01 or 0x00)  
        end
    end
    
    response:sendToPlayer(self)
end

-- overrides native function
-- to do: move to on connect event
-- to do: resend on reload

function sendItemClasses(cid)
    local player = Player(cid) 
    if (not player) then return false end

    local client = player:getClient()
    if (client) then
        local clientVersion = client.version
        if(clientVersion < 1280) then 
            return false 
        end
    end

    local msg = NetworkMessage()
    msg:addByte(BYTES.FORGE_RESPONSE_META)
    msg:addByte(#forgeMeta)
    if #forgeMeta > 0 then
        for classId, classData in pairs(forgeMeta) do
            msg:addByte(classId)
            msg:addByte(#classData)
            if #classData > 0 then
                for tierId = 0, #classData-1 do
                    msg:addByte(tierId)
                    msg:addU64(classData[tierId+1])
                end
            end
        end
    end
    
    -- other metadata
    
    --for i = 1, #forgeOrder do
    --    msg:addByte(forgeData[forgeOrder[i]])
    --end
    msg:addByte(forgeData.sliversDustCost)
    msg:addByte(forgeData.sliversPerConversion)
    msg:addByte(forgeData.coreSliversCost)
    msg:addByte(forgeData.dustLimitIncreaseCost)
    msg:addByte(forgeData.minStoredDustLimit)
    msg:addByte(forgeData.maxStoredDustLimit)
    msg:addByte(forgeData.fusionDustCost)
    msg:addByte(forgeData.transferDustCost)
	
	if player:isVip() then -- Custom System VIP
		msg:addByte(forgeData.fusionBaseSuccessRate + forgeData.vipBonus)    
	else
		msg:addByte(forgeData.fusionBaseSuccessRate)
	end

    msg:addByte(forgeData.fusionBonusSuccessRate)
    msg:addByte(forgeData.fusionReducedTierLossChance)

    
    msg:sendToPlayer(player)
end
